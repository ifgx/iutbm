\section{Langage}
    Le programme est entièrement codé en Python,
    et utilise la bibliothèque \emph{pygame}.
    \subsection{Python}
        Le \emph{Python} est un langage de programmation de haut niveau\footnote{Qui fait
        abstraction des détails de la machine sur laquelle il s'exécute} interprété
        \footnote{Au contraire des langages compilés, le python est évalué
        lignes par lignes par un \emph{interpréteur}, au lieu d'être exécuté directement
        par la machine}. Il fonctionne sur la plupart des plateformes informatiques.
    \subsection{pygame}
        pygame est une bibliothèque écrite en \emph{Python} initialement prévue pour
        le développement de jeux vidéo. Elle permet de programmer la partie multimédia
        (graphismes, sons, entrées des périphériques (clavier, couris, joystick,...),
        système de fenêtrage, ...) rapidement et facilement).

\section{Outils}
    Tout les outils utilisés, sans exception sont disponibles sous
    licence libre.
    \subsection{git}
        \emph{git} fût utilisé en gestionnaire de version,
        afin de simplifier le travail collaboratif.
        Il est également un excellent indicateur de la répartition
        de la charge de travail.
    \subsection{pep8, pylint}
        \emph{pep8}, et \emph{pylint} sont tout les deux
        des outils d'analyse statique de code \emph{Python}
        \subsubsection{pep8}
            \emph{pep8} se charge de vérifier si le code qui lui
            est fourni en entrée respecte bien les convention de codage
            python de la norme \emph{pep8} (le logiciel est homonyme).
        \subsubsection{pytlint} pylint est quant à lui un outil d'analyse
            statique pur et dur. Il vérifie grossièrement la sémantique du code,
            ainsi que sa présentation, et son respect des bonnes pratiques.
            Par exemple, si les classes\footnote{TODO} possèdent bien
            des commentaires les décrivant, ou encore si les modules
            \footnote{Un module est une \emph{brique} logicielle permettant
            de s'appuyer sur l'existant, et donc de ne pas réinventer la roue}
            importés sont bien utilisés, si les variables ont des noms corrects, ...
        \subsubsection{vim}
            Ce projet fût également l'occasion pour certain de découvrir \emph{vim},
            un puissant éditeur de texte modal.

\section{Menu principal}
    Le menu principal est un menu circulaire,
    permettant de choisir les algorithmes, et de
    quitter le programme.

\section{Algorithmes}
    \subsection{Voyageur de commerce}
        \paragraph{Moteur}
            Au démarrage du jeu, le programme génère un nuage
            de points (entièrement paramétrable en interne)
            répartis aléatoirement dans la fenêtre, et les affiche.
        \paragraph{Interface}
            L'utilisateur sélectionne les points par simple clic,
            et peut annuler ses actions par clic droit.
            A chaque point sélectionné, le programme
            affiche en temps réel la distance totale entre
            les points reliés.
            Lorsqu'un point a été sélectionné, le programme
            affiche la distance minimum calculée au-dessus de
            la distance actuelle parcourue par l'utilisateur.
            Lorsque tout les points ont étés reliés entre eux,
            le programme raccorde automatiquement le premier
            et le dernier point entre eux.
        \paragraph{Résolution}
            Lors de la sélectionne du premier point,
            le programme calcule à l'aide de l'algorithme
            du plus proche voisin optimisé par permutation
            le chemin le plus court.
            Une fois que l'utilisateur a relié tout les points
            entre eux, le programme affiche la solution calculée
            en surimpression de celle trouvée par l'utilisateur.

            L'algorithme du plus proche voisin consiste à avancer
            de proche en proche, en prenant à chaque itération le plus
            proche voisin du point actuel.
            La permutation permet d'optimiser un peu le résultat trouvé
            par l'algorithme du plus proche voisin.
            Il consiste en une permutation de deux points sur le chemin trouvé.
            Si la permutation réduit la longueur du chemin total,
            elle est conservé, sinon, on essaye une autre permutation,
            et ce, jusqu'à ce que tout les points aient été permutés.
        
	\subsection{Couplage}
		\paragraph{Contexte}
			Le but du jeu est de répartir un certain nombre de pizzas à un certain nombre de
			 clients. Chaque client dresse une liste de ses pizzas préférées; il faut alors,
			 en suivant ces directives, déterminer quelle est la meilleure façon de répartir
			 les pizzas entre les différents clients.

			Au terme de la résolution, il est possible qu'un ou plusieurs clients n'aient pas
			 de pizza, ou au contraire qu'une pizza ne soit distribuée à personne. Le but est
			 alors de satisfaire un maximum de clients.
		\paragraph{Moteur}
			Au démarrage du jeu, l'application génère une liste aléatoire de clients et une
			 liste aléatoire de pizzas. Ensuite, elle génère une liste aléatoire de couples
			 (client, pizza) représentant la liste des préférences de chaque client.
		\paragraph{Interface}
			L'utilisateur est présenté avec une liste de clients à gauche, et une liste
			 de pizzas à droite. En cliquant sur un client, la liste des pizzas préférées
			 du client s'affiche en bas de l'écran.

			L'utilisateur \emph{sélectionne} un client en cliquant dessus. Une fois un client
			 sélectionné, il clique sur la pizza qu'il souhaite attribuer à ce client. Si la
			 pizza est déjà attribuée à quelqu'un ou si le client a déjà une pizza, un message
			 d'erreur s'affiche; sinon, la pizza est associée au client: un trait rouge
			 s'affiche entre les deux.

			L'utilisateur a la possibilité d'annuler ses choix en cliquant avec le bouton
			 droit de la souris (ce qui annule la dernière action).
		\paragraph{Résolution}
			Chaque clients à une certaine liste de préférences concernant les pizzas.
			Nous pouvons symboliser ces préférences par les arrêtes d'un graphique où
			 les noeuds sont représentatif des clients et des pizzas.
			Pour satisfaire le maximum de clients, il est nécessaire de traiter d'abord
			 ceux qui ont le moins de pizzas dans leur liste de préférences, et donc, 
			 d'arrêtes sortant des noeuds clients, car on vise le nombre maximum de clients
			 satisfaits.
			Ensuite, on traite ceux qui ont le moins de liens, les uns après les autres,
			 suivant les desserts disponibles.
			Dans la représentation graphique, nous admettons qu'il y ait un noeud Source,
			 lié a tous les clients par des arrêtes de capacité 1, pour interdire le 
			 choix d'un client déjà satisfait.
			Ensuite, il y a un noeud Puit, similaire au noeud Source mais liés aux 
			 desserts.
			Lorsque l'on ne peut plus atteindre le noeud Puit a partir du noeud Source,
			 le jeu est terminé
			Si l'utilisateur n'a pas trouvé la solution optimale, la solution s'affiche
			 en surimpression sur le choix du joueur.

    \subsection{Sac à Dos}
        \paragraph{Contexte}
            Dans ce mini-jeu, le but du joueur est d'aider un pizzaiolo à
            sélectionner des ingrédients à transporter à un concours de pizza.
            Il ne peut pas prendre tout ce qu'il souhaite et doit faire des
            choix entre qualité et quantité : de bons ingrédients lui donnera
            plus de points par le jury, cependant la pizza présenté a un poids
            limité au gramme près.
        \paragraph{Moteur}
            Au démarrage de l'application, une liste d'ingrédients est créée.
            Pour respecter une certaine logique, on ne peux pas générer des
            chiffre aléatoirement. (Il semblerait assez illogique qu'une
            garniture au fromage pèse plusieurs centaines de grammes par
            exemple.)
        \paragraph{Interface}
            L'interface se présente en 2 colonnes. La première, à gauche,
            contient les objets disponible pour la pizza. La seconde, à droite,
            montre le contenu actuel de la pizza que le joueur à choisi.
            Un clic sur une icone d'un ingrédients permet de l'échanger entre
            les deux colonnes.
            Lorsque l'utilisateur a terminé, il clique sur le bouton de
            validation pour savoir si il a trouvé la solution correcte.
        \paragraph{Résolution}
            La résolution du problème s'effectue en utilisant un algorithme
            détaillé par notre professeur.
