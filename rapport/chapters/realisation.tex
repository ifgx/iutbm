\section{Algorithmes}
    \subsection{Voyageur de commerce}
        \subsubsection{Génération des données}
            La génération des données se fait en deux temps :
            \begin{enumerate}
                \item Génération de points à des coordonnées aléatoires
                \item Génération de la matrice des distances
            \end{enumerate}
        \subsubsection{Interface}
            L'utilisateur sélectionne les points par simple clic,
            et peut annuler ses actions par clic droit.
            A chaque point sélectionné, le programme
            affiche la distance totale entre les points reliés.
            Dès lors qu'un point a été sélectionné, le programme
            affiche la distance minimum calculée, au-dessus de
            la distance actuelle parcourue par l'utilisateur.
            Lorsque tout les points ont étés reliés entre eux,
            le programme raccorde automatiquement le premier
            et le dernier point, afin de former une boucle.
        \subsubsection{Résolution}
            Lors de la sélection du premier point,
            le programme calcule à l'aide de l'algorithme
            du \emph{plus proche voisin} le chemin le plus court.
            Une fois que l'utilisateur a relié tout les points
            entre eux, le programme affiche la solution calculée
            en surimpression de celle proposée par l'utilisateur.


	\subsection{Couplage}
		\paragraph{Contexte}
			Le probleme de couplage est modélisé par un jeu de choix.
			Il y a plusieurs clients, avec leurs préférences qui ont
			 le choix entre plusieurs pizzas, et le joueur doit 
			 satisfaire un maximum de clients.
		\paragraph{Moteur}
			Au demarrage de l'application, le nombre de pizzas et 
			 de clients est généré aléatoirement, dans un intervalle 
			 assez bas, par soucis de complexité.
			Les préférences de chaque client sont aussi générés aléatoirement,
			 mais dans l'optique qu'un client ait au minimum une préférences.
		\paragraph{Interface}
		    L'écran est divisé en trois colonnes :
		    \begin{itemize}
		        \item[à gauche] les préférences de chancun des clients
		        \item[au centre] les clients
		        \item[à droite] les pizzas disponibles
		    \end{itemize}

		L'utilisateur \emph{sélectionne} un client en cliquant dessus.
		    Une fois un client sélectionné, il est possible
		    d'associer une pizza à ce client, en cliquant dessus.
		    Si la pizza est déjà attribuée, ou si le client a déjà
		    une pizza qui lui est affectée, un message d'erreur s'affiche.
		    Si ni le client n'a de pizza, ni la pizza de client, l'association
		    se fait, et est représentée par un trait.
		L'utilisateur a la possibilité d'annuler ses choix en cliquant avec le bouton
		    droit de la souris (ce qui annule la dernière action).
		\paragraph{Résolution}
			L'algorithme permet d'avoir la solution comportant un maximum de clients
			 satisfait et de verifier si la solution proposée par le joueur correspond
			 a la meilleure solution possible.
 			Si l'utilisateur n'a pas trouvé la solution optimale, la solution s'affiche
			 en surimpression sur le choix du joueur.



    \subsection{Sac à Dos}
        \paragraph{Contexte}
        On pourra modéliser ce problème par un tableau contenant les objets et leur
        valeur en vis-à-vis. L'utilisateur fera glisser les objets du tableau vers
        le sac à dos. Un indicateur permettra de visualiser le poids actuel total
        des objets dans le sac, le poids maximal que peut supporter le sac, et le
        poids restant (différence entre ces deux résultats).

        On pourra scénariste ce jeu avec, par exemple, une histoire où un personnage
        doit quitter son château assiégé en emportant un maximum d'objets de valeur.


            Dans ce mini-jeu, le but du joueur est d'aider un pizzaiolo à
            sélectionner des ingrédients à transporter à un concours de pizza.
            Il ne peut pas prendre tout ce qu'il souhaite et doit faire des
            choix entre qualité et quantité : de bons ingrédients lui donnera
            plus de points par le jury, cependant la pizza présenté a un poids
            limité au gramme près.
        \paragraph{Moteur}
            Au démarrage de l'application, une liste d'ingrédients est créée.
            Pour respecter une certaine logique, on ne peux pas générer des
            chiffre aléatoirement. (Il semblerait assez illogique qu'une
            garniture au fromage pèse plusieurs centaines de grammes par
            exemple.)
        \paragraph{Interface}
            L'interface se présente en 2 colonnes. La première, à gauche,
            contient les objets disponible pour la pizza. La seconde, à droite,
            montre le contenu actuel de la pizza que le joueur à choisi.
            Un clic sur une icone d'un ingrédients permet de l'échanger entre
            les deux colonnes.
            Lorsque l'utilisateur a terminé, il clique sur le bouton de
            validation pour savoir si il a trouvé la solution correcte.
        \paragraph{Résolution}
            La résolution du problème s'effectue en utilisant un algorithme
            détaillé par notre professeur.


\subsection{Problème du plus court chemin}
        L'utilisateur pourra cliquer sur les différentes villes, tour à tour,
        pour déplacer le personnage. Un compteur kilométrique indiquera la
        distance parcourue.

        Le joueur peut effectuer un clic droit pour annuler son dernier
        mouvement.

        Le jeu continue tant que le joueur n'a pas trouvé le chemin
        le plus court. Il peut aussi cliquer sur \og solution\fg, qui
        affichera le chemin segment par segment.

        \paragraph{Contexte}
            Le but du jeu est de livrer une pizza en effectuant le moins de kilomètres possible.
        \paragraph{Moteur}
            Au démarrage du jeu, le programme génère un graphe
            représentant des villes. Ces villes sont reliées par des arcs pondérés.
            Le poids des arcs corresponds à la distance entre chaque villes.
            Il affiche les villes et les liaisons.

        \paragraph{Interface}
            L'utilisateur sélectionne les villes par simple clic,
            et peut annuler ses actions par clic droit.
            Pour revenir au début il suffit de cliquer sur la ville de départ.
            A chaque ville sélectionnée, le programme
            affiche en temps réel la distance totale parcourue.

        \paragraph{Résolution}
            Lorsque la ville de début et la ville finale sont reliées,
            on appelle la méthode de résolution par l'algorithme de \emph{Dijkstra}.

            Le programme affiche ensuite si le joueur à trouvé la solution optimale.

		\paragraph{Algorithme de Dijkstra} ~

			\begin{lstlisting}
liste_sommets = [+oo pour i dans sommets]
S(liste_sommets[0]) = 0
tant que taille(liste_sommets) != 0; faire
    element_courant = min(liste_sommets)
    pour chaque element_voisin dans liste_sommets; faire
        mettre_a_jour(element_voisin)
    fin pour
    supprimer element_courant de liste_sommets
fin tant que
			\end{lstlisting}

